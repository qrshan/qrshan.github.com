<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[侠客谷]]></title>
  <link href="http://qrshan.github.com/atom.xml" rel="self"/>
  <link href="http://qrshan.github.com/"/>
  <updated>2013-03-10T14:50:13+08:00</updated>
  <id>http://qrshan.github.com/</id>
  <author>
    <name><![CDATA[卿荣山]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[zz:体系结构期末复习——设计模式思考题]]></title>
    <link href="http://qrshan.github.com/blog/2013/03/10/code/"/>
    <updated>2013-03-10T14:20:00+08:00</updated>
    <id>http://qrshan.github.com/blog/2013/03/10/code</id>
    <content type="html"><![CDATA[<p>集合类型PROGRAMMING TO INTERFACE<br/>
题目：有一个数据列表DataList,其基本类型是3维向量ThreeD&lt;x,y,z>，1）用Java语言实现该数据列表的数据结构。假设有三个外部对象A,B,C,分别对其x、y、 z维度感兴趣,希望访问DataList在相应维 度的数据并进行处理。2)请定义其对外的数据接口。分别使用Iterator与Proxy。（PS：Iterator，Proxy需要自己实现）</p>

<!-- more -->


<p>Iterator:</p>

<pre><code>import java.util.*;

public class Iter {
    public static void main(String[] args) {
        Aggregate&lt;Integer, Integer, Integer&gt; ag = new DataList&lt;Integer, Integer, Integer&gt;();
        ((DataList)ag).add(new ThreeD&lt;Integer, Integer, Integer&gt;(1, 2, 3));
        ((DataList)ag).add(new ThreeD&lt;Integer, Integer, Integer&gt;(1, 2, 3));
        ((DataList)ag).add(new ThreeD&lt;Integer, Integer, Integer&gt;(1, 2, 3));
        Iterator&lt;Integer&gt; ia = ag.createIteratorA();
        while (ia.next() != null) {
            System.out.println(ia.currentItem());
        }
        Iterator&lt;Integer&gt; ib = ag.createIteratorB();
        while (ib.next() != null) {
            System.out.println(ib.currentItem());
        }
        Iterator&lt;Integer&gt; ic = ag.createIteratorC();
        while (ic.next() != null) {
            System.out.println(ic.currentItem());
        }
    }
}

class ThreeD&lt;T, V, W&gt; {

  private T t;
  private V v;
  private W w;

  public ThreeD(T t, V v, W w) {
this.t = t;
this.v = v;
this.w = w;
  }

  public T getA() { return t;}
  public V getB() { return v;}
  public W getC() { return w;}
}

interface Aggregate&lt;T, V, W&gt; {
  public Iterator&lt;T&gt; createIteratorA();
  public Iterator&lt;V&gt; createIteratorB();
  public Iterator&lt;W&gt; createIteratorC();
}

interface Iterator&lt;T&gt; {
  public T first();
  public T next();
  public boolean isDone();
  public T currentItem();
}

abstract class IteratorABC&lt;T&gt; implements Iterator&lt;T&gt;{
  protected DataList ag;
  protected int i;
  public IteratorABC(DataList ag) {
this.ag = ag;
i = -1;
  }
  public T first() { i = 0; return currentItem();}
  public T next() {i += 1; return currentItem();}
  public boolean isDone() {return i &gt;= ag.size() ;}
  public abstract T currentItem();
}


class IteratorA&lt;T&gt; extends IteratorABC&lt;T&gt;{
  public IteratorA(DataList ag) {
super(ag);
  }
  public T currentItem() { if (isDone()) return null; return (T)ag.get(i).getA();}
}

class IteratorB&lt;T&gt; extends IteratorABC&lt;T&gt;{
  public IteratorB(DataList ag) {
super(ag);
  }
  public T currentItem() { if (isDone()) return null; return (T)ag.get(i).getB();}
}

class IteratorC&lt;T&gt; extends IteratorABC&lt;T&gt;{
  public IteratorC(DataList ag) {
super(ag);
  }
  public T currentItem() { if (isDone()) return null; return (T)ag.get(i).getC();}
}

class DataList&lt;T, V, W&gt; implements Aggregate&lt;T, V, W&gt; {

  private ArrayList&lt;ThreeD&lt;T, V, W&gt;&gt; list = new ArrayList&lt;ThreeD&lt;T, V, W&gt;&gt;();
  private IteratorA&lt;T&gt; ia = new IteratorA&lt;T&gt;(this);
  private IteratorB&lt;V&gt; ib = new IteratorB&lt;V&gt;(this);
  private IteratorC&lt;W&gt; ic = new IteratorC&lt;W&gt;(this);

  public void add(ThreeD&lt;T, V, W&gt; d) { list.add(d); }  
  public ThreeD&lt;T, V, W&gt; get(int index) { return list.get(index); }  
  public int size() {return list.size();}  

  public Iterator&lt;T&gt; createIteratorA() { return ia; }  
  public Iterator&lt;V&gt; createIteratorB() { return ib; }  
  public Iterator&lt;W&gt; createIteratorC() { return ic; }  
}
</code></pre>

<p>Proxy:</p>

<pre><code>import java.util.*;

public class Proxy {
  public static void main(String[] args) {
  }
}

class ThreeD&lt;T, V, W&gt; {

  private T t;
  private V v;
  private W w;

  public ThreeD(T t, V v, W w) {
    this.t = t;
    this.v = v;
    this.w = w;
  }

  public T getA() { return t;}
  public V getB() { return v;}
  public W getC() { return w;}
}

interface IDataList&lt;T, V, W&gt; {
  public T getA(int i) throws Exception;
  public V getB(int i) throws Exception;
  public W getC(int i) throws Exception;
  public int size();
}

abstract class DataListProxy&lt;T, V, W&gt; implements IDataList&lt;T, V, W&gt; {
  protected IDataList&lt;T, V, W&gt; real;
  public DataListProxy(IDataList&lt;T, V, W&gt; real) {this.real = real;}
  public T getA(int i) throws Exception {throw new Exception(); }
  public V getB(int i) throws Exception {throw new Exception(); }
  public W getC(int i) throws Exception {throw new Exception(); }
  public int size() { return real.size(); }
}


class DataListProxyA&lt;T, V, W&gt; extends DataListProxy&lt;T, V, W&gt; {
  public DataListProxyA(IDataList&lt;T, V, W&gt; real) {super(real);}
  public T getA(int i) throws Exception {return real.getA(i); }
}

class DataListProxyB&lt;T, V, W&gt; extends DataListProxy&lt;T, V, W&gt; {
  public DataListProxyB(IDataList&lt;T, V, W&gt; real) {super(real);}
  public V getB(int i) throws Exception {return real.getB(i); }
}

class DataListProxyC&lt;T, V, W&gt; extends DataListProxy&lt;T, V, W&gt; {
  public DataListProxyC(IDataList&lt;T, V, W&gt; real) {super(real);}
  public W getC(int i) throws Exception {return real.getC(i); }
}

class DataList&lt;T, V, W&gt; implements IDataList&lt;T, V, W&gt; {

  private ArrayList&lt;ThreeD&lt;T, V, W&gt;&gt; list = new ArrayList&lt;ThreeD&lt;T, V, W&gt;&gt;();

  public void add(ThreeD&lt;T, V, W&gt; d) { list.add(d); }
  public ThreeD&lt;T, V, W&gt; get(int index) { return list.get(index); }
  public int size() {return list.size();}
  public T getA(int i) { return list.get(i).getA(); }
  public V getB(int i) { return list.get(i).getB(); }
  public W getC(int i) { return list.get(i).getC(); }
}
</code></pre>

<p>Decorator, OCP<br/>
题目：对如下继承树进行扩展，Border（Plain，3D, Fancy) ScrollBar(Horiz, Vert)</p>

<pre><code>abstract class VisualComponent {
  void draw();
  void resize();
}
class TextView extends VisualComponent {
  void draw() {...}
  void resize() {...}
}
class StreamVidoView  VisualComponent {
  void draw() {...}
  void resize() {...}
}
</code></pre>

<p>解答：</p>

<pre><code>abstract class Decorator extends VisualComponent {
  VisualComponent vc;
  Decorator(VisualComponent vc) {this.vc = vc;}
  void draw() {vc.draw();}
  void resize() {vc.resize();}
}

abstract class Border extends Decorator {
  void draw() {super.draw(); drawBorder();}
  abstract void drawBorder();
}

class PlainBorder extends Border {
  void drawBorder() {...}
}

...
</code></pre>

<p>Information Hiding &amp; Common and Variation<br/>
题目：比较 facade 与 controller 的异同</p>

<p>相同：</p>

<ul>
<li><p>它们自己不进行一些逻辑处理，都只是进行一些任务转发的功能</p></li>
<li><p>它们都是对两个模块或外部和内部进行解耦</p></li>
<li><p>都是抽出来的一层，屏蔽了底层的接口<br/>
不同：</p></li>
<li><p>facade 主要关注的是模块之间的解耦和信息隐藏，为一个子系统提供一个简单的，外在的接口，任意两个之间，只要有一些解耦的需求，都可以用 facade 。而 controller 的目的是对应用户需求，职责分配，主要处理当来了一个请求或什么的，具体要分配给那个对象取。</p></li>
<li><p>（yy）facade由于是为了模块的解耦，在两个基本的类之间做一个 facade 是没有意义的。而 controller 目的是为了让用户的请求和处理之间彼此独立，所以可以存在两个类之间有一个controller。</p></li>
<li><p>Façade是个比较奇怪的模式，它没有Solution Structure，因为它只是一种思想，一种对局部复杂结构进行包装和简化，以达到信息隐藏的一种想法而已。<br/>
题目：在策略模式中, 为什么使用“聚合”而不是 “关联”关系?</p></li>
</ul>


<p>聚合可以说是一种比较强的关联，聚合指出在对象 A 中需要有 B 的应用，而关联仅仅是一种使用关系。由于关联没有规定 A 中有B的引用，那么如果 策略模式使用关联来实现，那么就无法解决综合使用多个策略的问题，它要么使用一个策略，要么策略的个数是确定的。</p>

<p>策略模式相比，如果 context 不包含 strategy 就语义上出问题了，因为 strategy 是从 context 中分割出来的，应该是 context 的一部分。</p>

<p>Common and Variation</p>

<p>问题：如果一个对象集之间除共性外,有超过2个的差异行为,如何处理?<br/>
两棵策略树</p>

<p>问题：如果一个对象集的部分行为组存在差异性,如何处理?<br/>
把行为组放在策略中</p>

<p>问题：问题：如果一个对象集的部分属性(以及依赖于这些属性的方法)存在差异性,如何处理?  <br/>
把这些属性和方法放在策略中</p>

<p>问题：如果一个对象集的一个行为需要协作对象来完成,但是它们的协作对象存在差异性,如何处理?<br/>
在协作对象上加上一个adapter组成策略（Command Pattern）</p>

<p>问题：如果一个对象集的行为因为属性的取值而存在差异性,如何处理?<br/>
state pattern</p>

<p>Compare strategy and state</p>

<p>from stackoverflow</p>

<p>The Strategy pattern is really about having a different implementation that accomplishes (basically) the same thing, so that one implementation can replace the other as the strategy requires. For example, you might have different sorting algorithms in a strategy pattern. The callers to the object does not change based on which strategy is being employed, but regardless of strategy the goal is the same (sort the collection).</p>

<p>The State pattern is about doing different things based on the state, while leaving the caller releaved from the burden of accommodating every possible state. So for example you might have a getStatus() method that will return different statuses based on the state of the object, but the caller of the method doesn’t have to be coded differently to account for each potential state.</p>

<p>“1 of N” or “M of N”?</p>

<p>strategy M of N, state 通常是 1 of N ，但是在并发的情况下是 M of N</p>

<p>Who control the change of variation?</p>

<p>That is the difference between “Context decide changing of ConcreteState object” and “ConcreteState desice changing of Concrete State” 有什么不同<br/>
State 是由自己控制变化的，而 strategy 通常是由 context 控制变化的。State 自己控制变化的过程是隐式的，外部不知道现在的状态和下一个状态将要是什么，而由 context 控制变化的时候，是能够控制变化的。通常 Strategy 都是完成的同一个功能，State 不一定。</p>

<p>How to change? Fixed rules of configuration files</p>

<p>都可以，但是个人认为 state 通常是 fixed rules，strategy 通常是 configuration files</p>

<p>Crating and destroying policy?</p>

<p>state: 除了第一个之外，都是由 state 自己创建，并且是由 state 自己销毁的。<br/>
strategy: 是由 Client 创建，也由 Client 销毁</p>

<p>Common and Variation<br/>
使用Bridge Pattern实现一个画图程序的主体框架</p>

<ul>
<li><p>图形：点、线、矩形、圆…</p></li>
<li><p>线形：实线、虚线、双线…</p></li>
<li>线粗细：1x、2x、4x</li>
<li>颜色：RGB<br/>
<del> 由于只有图形和线形是可变的类型，因此 Bridge Pattern 的两个继承树图形和线形。 </del></li>
</ul>


<p>问：题目中的后两个没有省略号是否意味着将来不会变化？如果不会变化的画可不可以把线的粗细和颜色RGB当作draw的属性？<br/>
丁老师说：<br/>
例子只是要你们思考一下Bridge的同时试着综合一下差异性处理，所以需求没有给的那么精确，如果实际写代码的话，估计线形、粗细和颜色都是draw方法的参数而已，但是如果考试的话，会专门要求上述三个方面独立处理的，也就是要有三个策略树以解决三种相互独立的差异性<br/>
问：如果使用三个策略树的话，还算是用了bridge pattern 吗？<br/>
丁老师说：<br/>
严格上讲，不是Bridge了，比Bridge更加复杂了，解决了抽象与实现分离的同时，做到了实现自身又包含多种相互独立差异性的问题。<br/>
Runtime Registration<br/>
与真正自实现的Event Style相比,ObserverPattern的不同在哪里?</p>

<ul>
<li><p>Event Style 中需要管理多种 Event 事件；而 ObserverPattern 只通常只需要管理一种，即自己的变化</p></li>
<li><p>Event Style 中 EventRoute 有储存关于 Event 和 ObserverList 的一个 Dictionary；Observer 中 Subject 只有一个列表</p></li>
<li><p>Event Style 中 EventRoute 只是一个事件路由，没有除了一个 Dictionary 没有其他的属于自己的信息；而 Observer 中的 Subject 包含有 Subject 信息</p></li>
<li><p>Event Style 中的事件发起的原因是第三方触发了事件；而 Observer 中 update 触发的原因是 Subject 自己的数据发生了变化，虽然是由于第三方的修改，但是时间是由自己触发的</p></li>
</ul>


<p>如果众多Observer的接口不相同怎么办? 不都是update接口,甚至不是同一种类型</p>

<p>使用一个adapter使它们的接口统一</p>

<p>用 observer 编写程序</p>

<p>要求：</p>

<ul>
<li><p>Model: student（ID, name, birthday)</p></li>
<li><p>View:</p>

<ul>
<li>View1:显示ID+name</li>
<li>View2:显示ID+birthday</li>
<li>View3:修改student的三个列</li>
</ul>
</li>
<li><p>View1~2为observer,model为subject</p>

<ul>
<li>实现每次view3中实现修改后</li>
<li>View1~2自动更新<br/>
示例：<br/>
by Kavin Yao : https://gist.github.com/2977200</li>
</ul>
</li>
</ul>


<p>Creation<br/>
以singleton为基础,编写程序解决上述问题(Limited instance permited)</p>

<pre><code>import java.util.*;
public class Limiton {
  private static int limit = 3;
  private static Limiton[] instances = new Limiton[3]; 
  private static Random r = new Random();
  static {
    for (int i = 0; i &lt; limit; i++) {
      instances[i] = new Limiton();
    }
  }
  private Limiton(){}
  public static Limiton getInstance() {
    int i = r.nextInt(limit);
    return instances[i];
  }
}
</code></pre>

<p>A thread safe version:</p>

<pre><code>import java.util.*;
public class Limiton {
  private static int limit = 3;
  private static class LimitonHolder {
    private static Limiton[] instances = new Limiton[3]; 
    static {
      for (int i = 0; i &lt; limit; i++) {
        instances[i] = new Limiton();
      }
    }
  }
  private static Random r = new Random();
  private Limiton(){}
  public static Limiton getInstance() {
    int i = r.nextInt(limit);
    return LimitonHolder.instances[i];
  }
}
</code></pre>

<p>这是最简单的情况，如果需要考虑到如何选择 instance ，或者一个 instance 只能有一个外部引用，那么就要考虑其他东西了。<br/>
An Example: https://gist.github.com/2978425</p>

<p>如果有多个其他类实例的创建类型都需要子类来决定怎么办?</p>

<p>在工厂方法里的里面使用多个 factoryMethod，比如 facotryMethodA，factoryMethodB</p>

<p>如果多个其他类实例之间存在类型依赖该怎么办?</p>

<p>如果类的种类（抽象类）的个数是确定的、不会轻易改变(也就是 Product 的种类是相对稳定的)，并且类的依赖呈现 product family，那使用 Abstract Factory</p>

<p>That&#8217;s All *<sup>o<sup>*</sup></sup> ~~~</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[octopress工作环境迁移测试]]></title>
    <link href="http://qrshan.github.com/blog/2013/03/03/test111/"/>
    <updated>2013-03-03T22:04:00+08:00</updated>
    <id>http://qrshan.github.com/blog/2013/03/03/test111</id>
    <content type="html"><![CDATA[<p>今天将octopress的工作环境从原来的笔记本电脑上门迁移至了我寝室的台式机上，测试一下o(≧v≦)o~~</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[论UCLA空切]]></title>
    <link href="http://qrshan.github.com/blog/2013/02/06/titil1/"/>
    <updated>2013-02-06T21:06:00+08:00</updated>
    <id>http://qrshan.github.com/blog/2013/02/06/titil1</id>
    <content type="html"><![CDATA[<p>这次回家之后在医院的球场打野球。但是不知怎的NBA巨星抱团的风气也已经影响到了野球场上了。最近球星老是喜欢跟光头一家，以致于我们经常被打得很没脾气。我想无论是在野球场上还是在比赛场上，普通队员想要跟球星组合对抗，则必须打出很好的战术和执行力。而在整个现代篮球中，约翰-伍登教练的UCLA空切战术对于我们的进攻体系影响深远。<br/>
美国篮球之父约翰·伍登教练，于2010年6月5日以99岁高龄，辞世而去。99岁，虽未及百，但按中国的说话，九九归一，亦是善终。何况伍登教练这一生，著书立说，恩泽后辈，桃李满天下，更兼10次率领UCLA（加州大学洛杉矶分校）夺取美国大学联赛冠军，创下无法超越的伟业，著名的UCLA进攻，也成为全美甚至世界篮球最经典的教科书，可谓并无遗憾。告别人世之际，伍登教练颇为平静，此生足矣。</p>

<!-- more -->


<p><img src="http://qrshan.github.com/images/johnwooden.jpg" alt="约翰-伍登" />
伍登教练一生从未离开大学篮球，从未执教NBA。他始终认为，只有大学篮球才是最纯粹的篮球，运动员才能最忠实的体现教练的意图，而在NBA，商业氛围太重，运动员的天赋往往主导一切。尽管伍登教练从未涉足NBA，但他对美国篮球（包括NBA）战术打法的整体影响无人可及。无数后辈的出色教练，篮球理念、基础打法，都是建立在UCLA进攻的基础之上。UCLA进攻，因此生出大量的分枝。<br/>
我只说两个简单的分枝，就足以令你知道UCLA进攻的始祖地位。伍登教练在传授UCLA进攻时，强调有十大原则，其中第二条原则，便是三角进攻原则。它最初并不是一套固定打法，而是在UCLA进攻执行中的原则，要求在一侧至少形成两个接应点，不断在三个人之间形成三角。泰克斯·温特，三角进攻的创始人，正是在UCLA进攻的三角进攻原则的基础上，总结创立出一套成型的三角进攻打法。菲尔·杰克逊靠着手上的超群天赋和这套打法，迄今赢得了10个冠军。名扬天下的三角进攻，正是来自UCLA进攻的分枝。<br/>
当贾巴尔在UCLA读书时，伍登教练的打法以低位的贾巴尔为轴心，为队友创造进攻机会。后来贾巴尔毕业进入NBA，比尔·沃顿进入UCLA。沃顿和贾巴尔同为中锋，但有截然不同的技术特点。沃顿没有贾巴尔那么出色的篮下攻击力，但他更擅长传球，更能在高位发挥作用。伍登教练因材施教，修改了自己的打法，以罚球线落位的沃顿为核心，让UCLA始终位于不败之地。沃顿落在罚球线以上位置，其他队员利用相互掩护，空切反跑，更让人防不胜防。伍登教练的助教皮特·卡瑞尔，在离开伍登之后，依靠这一中锋居于高位的理念，在普林斯顿大学发扬光大，最终形成了普林斯顿进攻。  <br/>
你也许从不了解伍登。但仅仅是这两个分枝，已经足以让你敬重这位教练。因为UCLA进攻对进攻整体性的强调，打明星打个人的NBA并没有太多球队使用这套打法（仅有老帅斯隆和他的犹他爵士一直坚持使用）。但无论你打不打UCLA进攻，在美国各级球队（包括NBA）之中，UCLA进攻的一招进攻发起方式——UCLA空切（UCLA CUT），都已经被作为一套最常使用的战术发起方式，使用率超过70%。UCLA空切，因此成了美国球场上最常见的打法，也是电视解说中最常说到的名词。UCLA空切，就像武学打法的起始招式，可称千古一式。<br/>
那么，究竟什么是UCLA空切？起始后又有哪些基本变化招式？在此跟大家一叙。
<img src="http://qrshan.github.com/images/uclacut.jpg" alt="UCLA空切" />
<strong>如图所示：</strong>
UCLA空切，初始采用2-3落位。1持球过半场，佯装寻找4，随后横向转移至2。2斜传至45度的3，与此同时，5自底线上提至罚球线，给2做下掩护。2此时需坚决凶狠的利用5的掩护，向底线空切，这一切，便是经典的UCLA空切。这一切，绝不是为了简单移动而切，而是要极富攻击性，将对方的防守阵型下压，以此给高位腾出执行进攻的空间，创造机会。如果2的防守人被5掩护住，3可立刻传球给2，2将获得直接攻击篮筐的机会。无论如何，2的凶狠空切，都会造成对方防守向回收缩。此时3横传给5，5在罚球线持球瞄篮，可投可传，4自另一侧向篮下横移。5和4，形成经典的高低位进攻（HIGH-LOW）。<br/>
5此时有四个基本选择：自己投篮、内传内给4、3向内移动给2掩护，2兜出接5传球跳投、寻找弱侧的1，形成三角，再由1喂球给4。如球在3手中时，无法交给5，则1向强侧移动，4从底线上提罚球线，5向侧移动，和3给2做双掩护，为2创造兜出投篮机会。1既可以喂球给2，也可以向4移动，做手递手或者传切配合。<br/>
这便是UCLA空切之后的基本演化定式，此外还有数般变化，皆在此基础上演进，变化无穷。比如，德隆·威廉姆斯将球打到3号位，利用奥库（5号位）的掩护向下空切，如果防守提前绕过掩护，他也曾经在奥库身边突然停步，后撤步接3号位传球三分跳投；拥有出色背身单打能力的2号位，比如科比，利用拜纳姆的掩护向下切，无论是否摆脱防守，对方防守空间都已拉开，给科比创造了在低位背身单打的机会。一招UCLA空切，在不断移动中不断创造机会，场上的五个人手上都有机会出现，防不胜防。这套打法起势，最大程度展现了五人参与的集体进攻。<br/>
这两天，我看到一些球迷在悼念伍登教练的时候说“你的挡拆战术不朽”。看了上面的介绍，你就会知道，其实这是一种误读。因为爵士队打UCLA进攻，同时爵士20年来又以马龙-斯托克顿，德隆-布泽尔的挡拆闻名，让一些球迷误以为，伍登教练的UCLA进攻主打挡拆。事实上，伍登教练的UCLA进攻很少打挡拆，也并不鼓励由两个人掌控球队的进攻，而是要求五个人都有机会。爵士擅打挡拆，是老斯隆根据马龙-斯托克顿的个人特点和默契，用两人挡拆丰富UCLA进攻的手段，而不是伍登教练的本意。<br/>
对于伍登教练而言，球永远是场上五个人打的，是全队12个人打的。超级明星们可能对此不以为然，但谁也改变不了，伍登教练的泰斗之位。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[octopress 初体验]]></title>
    <link href="http://qrshan.github.com/blog/2013/02/02/octopress-hello-world/"/>
    <updated>2013-02-02T12:14:00+08:00</updated>
    <id>http://qrshan.github.com/blog/2013/02/02/octopress-hello-world</id>
    <content type="html"><![CDATA[<p><em>hello world</em>!<strong>octopress</strong>!你好！ <br/>
今天一早都受困于octopress无法插入中文，试了修改环境变量：<br/>
LC_ALL=zh_CN.UTF-8<br/>
LANG=zh_CN.UTF-8<br/>
均不成功，后来经过考证发现如下几个问题才得以成功插入中文：<br/>
<em>1、markdown文件如果出现了中文请另存为<strong>UTF-8格式且去掉BOM头</strong>。<br/>
2、yaml的冒号后要有<strong>空格</strong>。<br/>
3、把设置环境变量里的zh_CN改成<strong>en_US</strong></em><br/>
如此设置，中文乱码问题就解决了。</p>
]]></content>
  </entry>
  
</feed>
