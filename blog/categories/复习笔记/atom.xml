<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: 复习笔记 | 侠客谷]]></title>
  <link href="http://qrshan.github.com/blog/categories/复习笔记/atom.xml" rel="self"/>
  <link href="http://qrshan.github.com/"/>
  <updated>2013-03-10T14:50:13+08:00</updated>
  <id>http://qrshan.github.com/</id>
  <author>
    <name><![CDATA[卿荣山]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[zz:体系结构期末复习——设计模式思考题]]></title>
    <link href="http://qrshan.github.com/blog/2013/03/10/code/"/>
    <updated>2013-03-10T14:20:00+08:00</updated>
    <id>http://qrshan.github.com/blog/2013/03/10/code</id>
    <content type="html"><![CDATA[<p>集合类型PROGRAMMING TO INTERFACE<br/>
题目：有一个数据列表DataList,其基本类型是3维向量ThreeD&lt;x,y,z>，1）用Java语言实现该数据列表的数据结构。假设有三个外部对象A,B,C,分别对其x、y、 z维度感兴趣,希望访问DataList在相应维 度的数据并进行处理。2)请定义其对外的数据接口。分别使用Iterator与Proxy。（PS：Iterator，Proxy需要自己实现）</p>

<!-- more -->


<p>Iterator:</p>

<pre><code>import java.util.*;

public class Iter {
    public static void main(String[] args) {
        Aggregate&lt;Integer, Integer, Integer&gt; ag = new DataList&lt;Integer, Integer, Integer&gt;();
        ((DataList)ag).add(new ThreeD&lt;Integer, Integer, Integer&gt;(1, 2, 3));
        ((DataList)ag).add(new ThreeD&lt;Integer, Integer, Integer&gt;(1, 2, 3));
        ((DataList)ag).add(new ThreeD&lt;Integer, Integer, Integer&gt;(1, 2, 3));
        Iterator&lt;Integer&gt; ia = ag.createIteratorA();
        while (ia.next() != null) {
            System.out.println(ia.currentItem());
        }
        Iterator&lt;Integer&gt; ib = ag.createIteratorB();
        while (ib.next() != null) {
            System.out.println(ib.currentItem());
        }
        Iterator&lt;Integer&gt; ic = ag.createIteratorC();
        while (ic.next() != null) {
            System.out.println(ic.currentItem());
        }
    }
}

class ThreeD&lt;T, V, W&gt; {

  private T t;
  private V v;
  private W w;

  public ThreeD(T t, V v, W w) {
this.t = t;
this.v = v;
this.w = w;
  }

  public T getA() { return t;}
  public V getB() { return v;}
  public W getC() { return w;}
}

interface Aggregate&lt;T, V, W&gt; {
  public Iterator&lt;T&gt; createIteratorA();
  public Iterator&lt;V&gt; createIteratorB();
  public Iterator&lt;W&gt; createIteratorC();
}

interface Iterator&lt;T&gt; {
  public T first();
  public T next();
  public boolean isDone();
  public T currentItem();
}

abstract class IteratorABC&lt;T&gt; implements Iterator&lt;T&gt;{
  protected DataList ag;
  protected int i;
  public IteratorABC(DataList ag) {
this.ag = ag;
i = -1;
  }
  public T first() { i = 0; return currentItem();}
  public T next() {i += 1; return currentItem();}
  public boolean isDone() {return i &gt;= ag.size() ;}
  public abstract T currentItem();
}


class IteratorA&lt;T&gt; extends IteratorABC&lt;T&gt;{
  public IteratorA(DataList ag) {
super(ag);
  }
  public T currentItem() { if (isDone()) return null; return (T)ag.get(i).getA();}
}

class IteratorB&lt;T&gt; extends IteratorABC&lt;T&gt;{
  public IteratorB(DataList ag) {
super(ag);
  }
  public T currentItem() { if (isDone()) return null; return (T)ag.get(i).getB();}
}

class IteratorC&lt;T&gt; extends IteratorABC&lt;T&gt;{
  public IteratorC(DataList ag) {
super(ag);
  }
  public T currentItem() { if (isDone()) return null; return (T)ag.get(i).getC();}
}

class DataList&lt;T, V, W&gt; implements Aggregate&lt;T, V, W&gt; {

  private ArrayList&lt;ThreeD&lt;T, V, W&gt;&gt; list = new ArrayList&lt;ThreeD&lt;T, V, W&gt;&gt;();
  private IteratorA&lt;T&gt; ia = new IteratorA&lt;T&gt;(this);
  private IteratorB&lt;V&gt; ib = new IteratorB&lt;V&gt;(this);
  private IteratorC&lt;W&gt; ic = new IteratorC&lt;W&gt;(this);

  public void add(ThreeD&lt;T, V, W&gt; d) { list.add(d); }  
  public ThreeD&lt;T, V, W&gt; get(int index) { return list.get(index); }  
  public int size() {return list.size();}  

  public Iterator&lt;T&gt; createIteratorA() { return ia; }  
  public Iterator&lt;V&gt; createIteratorB() { return ib; }  
  public Iterator&lt;W&gt; createIteratorC() { return ic; }  
}
</code></pre>

<p>Proxy:</p>

<pre><code>import java.util.*;

public class Proxy {
  public static void main(String[] args) {
  }
}

class ThreeD&lt;T, V, W&gt; {

  private T t;
  private V v;
  private W w;

  public ThreeD(T t, V v, W w) {
    this.t = t;
    this.v = v;
    this.w = w;
  }

  public T getA() { return t;}
  public V getB() { return v;}
  public W getC() { return w;}
}

interface IDataList&lt;T, V, W&gt; {
  public T getA(int i) throws Exception;
  public V getB(int i) throws Exception;
  public W getC(int i) throws Exception;
  public int size();
}

abstract class DataListProxy&lt;T, V, W&gt; implements IDataList&lt;T, V, W&gt; {
  protected IDataList&lt;T, V, W&gt; real;
  public DataListProxy(IDataList&lt;T, V, W&gt; real) {this.real = real;}
  public T getA(int i) throws Exception {throw new Exception(); }
  public V getB(int i) throws Exception {throw new Exception(); }
  public W getC(int i) throws Exception {throw new Exception(); }
  public int size() { return real.size(); }
}


class DataListProxyA&lt;T, V, W&gt; extends DataListProxy&lt;T, V, W&gt; {
  public DataListProxyA(IDataList&lt;T, V, W&gt; real) {super(real);}
  public T getA(int i) throws Exception {return real.getA(i); }
}

class DataListProxyB&lt;T, V, W&gt; extends DataListProxy&lt;T, V, W&gt; {
  public DataListProxyB(IDataList&lt;T, V, W&gt; real) {super(real);}
  public V getB(int i) throws Exception {return real.getB(i); }
}

class DataListProxyC&lt;T, V, W&gt; extends DataListProxy&lt;T, V, W&gt; {
  public DataListProxyC(IDataList&lt;T, V, W&gt; real) {super(real);}
  public W getC(int i) throws Exception {return real.getC(i); }
}

class DataList&lt;T, V, W&gt; implements IDataList&lt;T, V, W&gt; {

  private ArrayList&lt;ThreeD&lt;T, V, W&gt;&gt; list = new ArrayList&lt;ThreeD&lt;T, V, W&gt;&gt;();

  public void add(ThreeD&lt;T, V, W&gt; d) { list.add(d); }
  public ThreeD&lt;T, V, W&gt; get(int index) { return list.get(index); }
  public int size() {return list.size();}
  public T getA(int i) { return list.get(i).getA(); }
  public V getB(int i) { return list.get(i).getB(); }
  public W getC(int i) { return list.get(i).getC(); }
}
</code></pre>

<p>Decorator, OCP<br/>
题目：对如下继承树进行扩展，Border（Plain，3D, Fancy) ScrollBar(Horiz, Vert)</p>

<pre><code>abstract class VisualComponent {
  void draw();
  void resize();
}
class TextView extends VisualComponent {
  void draw() {...}
  void resize() {...}
}
class StreamVidoView  VisualComponent {
  void draw() {...}
  void resize() {...}
}
</code></pre>

<p>解答：</p>

<pre><code>abstract class Decorator extends VisualComponent {
  VisualComponent vc;
  Decorator(VisualComponent vc) {this.vc = vc;}
  void draw() {vc.draw();}
  void resize() {vc.resize();}
}

abstract class Border extends Decorator {
  void draw() {super.draw(); drawBorder();}
  abstract void drawBorder();
}

class PlainBorder extends Border {
  void drawBorder() {...}
}

...
</code></pre>

<p>Information Hiding &amp; Common and Variation<br/>
题目：比较 facade 与 controller 的异同</p>

<p>相同：</p>

<ul>
<li><p>它们自己不进行一些逻辑处理，都只是进行一些任务转发的功能</p></li>
<li><p>它们都是对两个模块或外部和内部进行解耦</p></li>
<li><p>都是抽出来的一层，屏蔽了底层的接口<br/>
不同：</p></li>
<li><p>facade 主要关注的是模块之间的解耦和信息隐藏，为一个子系统提供一个简单的，外在的接口，任意两个之间，只要有一些解耦的需求，都可以用 facade 。而 controller 的目的是对应用户需求，职责分配，主要处理当来了一个请求或什么的，具体要分配给那个对象取。</p></li>
<li><p>（yy）facade由于是为了模块的解耦，在两个基本的类之间做一个 facade 是没有意义的。而 controller 目的是为了让用户的请求和处理之间彼此独立，所以可以存在两个类之间有一个controller。</p></li>
<li><p>Façade是个比较奇怪的模式，它没有Solution Structure，因为它只是一种思想，一种对局部复杂结构进行包装和简化，以达到信息隐藏的一种想法而已。<br/>
题目：在策略模式中, 为什么使用“聚合”而不是 “关联”关系?</p></li>
</ul>


<p>聚合可以说是一种比较强的关联，聚合指出在对象 A 中需要有 B 的应用，而关联仅仅是一种使用关系。由于关联没有规定 A 中有B的引用，那么如果 策略模式使用关联来实现，那么就无法解决综合使用多个策略的问题，它要么使用一个策略，要么策略的个数是确定的。</p>

<p>策略模式相比，如果 context 不包含 strategy 就语义上出问题了，因为 strategy 是从 context 中分割出来的，应该是 context 的一部分。</p>

<p>Common and Variation</p>

<p>问题：如果一个对象集之间除共性外,有超过2个的差异行为,如何处理?<br/>
两棵策略树</p>

<p>问题：如果一个对象集的部分行为组存在差异性,如何处理?<br/>
把行为组放在策略中</p>

<p>问题：问题：如果一个对象集的部分属性(以及依赖于这些属性的方法)存在差异性,如何处理?  <br/>
把这些属性和方法放在策略中</p>

<p>问题：如果一个对象集的一个行为需要协作对象来完成,但是它们的协作对象存在差异性,如何处理?<br/>
在协作对象上加上一个adapter组成策略（Command Pattern）</p>

<p>问题：如果一个对象集的行为因为属性的取值而存在差异性,如何处理?<br/>
state pattern</p>

<p>Compare strategy and state</p>

<p>from stackoverflow</p>

<p>The Strategy pattern is really about having a different implementation that accomplishes (basically) the same thing, so that one implementation can replace the other as the strategy requires. For example, you might have different sorting algorithms in a strategy pattern. The callers to the object does not change based on which strategy is being employed, but regardless of strategy the goal is the same (sort the collection).</p>

<p>The State pattern is about doing different things based on the state, while leaving the caller releaved from the burden of accommodating every possible state. So for example you might have a getStatus() method that will return different statuses based on the state of the object, but the caller of the method doesn’t have to be coded differently to account for each potential state.</p>

<p>“1 of N” or “M of N”?</p>

<p>strategy M of N, state 通常是 1 of N ，但是在并发的情况下是 M of N</p>

<p>Who control the change of variation?</p>

<p>That is the difference between “Context decide changing of ConcreteState object” and “ConcreteState desice changing of Concrete State” 有什么不同<br/>
State 是由自己控制变化的，而 strategy 通常是由 context 控制变化的。State 自己控制变化的过程是隐式的，外部不知道现在的状态和下一个状态将要是什么，而由 context 控制变化的时候，是能够控制变化的。通常 Strategy 都是完成的同一个功能，State 不一定。</p>

<p>How to change? Fixed rules of configuration files</p>

<p>都可以，但是个人认为 state 通常是 fixed rules，strategy 通常是 configuration files</p>

<p>Crating and destroying policy?</p>

<p>state: 除了第一个之外，都是由 state 自己创建，并且是由 state 自己销毁的。<br/>
strategy: 是由 Client 创建，也由 Client 销毁</p>

<p>Common and Variation<br/>
使用Bridge Pattern实现一个画图程序的主体框架</p>

<ul>
<li><p>图形：点、线、矩形、圆…</p></li>
<li><p>线形：实线、虚线、双线…</p></li>
<li>线粗细：1x、2x、4x</li>
<li>颜色：RGB<br/>
<del> 由于只有图形和线形是可变的类型，因此 Bridge Pattern 的两个继承树图形和线形。 </del></li>
</ul>


<p>问：题目中的后两个没有省略号是否意味着将来不会变化？如果不会变化的画可不可以把线的粗细和颜色RGB当作draw的属性？<br/>
丁老师说：<br/>
例子只是要你们思考一下Bridge的同时试着综合一下差异性处理，所以需求没有给的那么精确，如果实际写代码的话，估计线形、粗细和颜色都是draw方法的参数而已，但是如果考试的话，会专门要求上述三个方面独立处理的，也就是要有三个策略树以解决三种相互独立的差异性<br/>
问：如果使用三个策略树的话，还算是用了bridge pattern 吗？<br/>
丁老师说：<br/>
严格上讲，不是Bridge了，比Bridge更加复杂了，解决了抽象与实现分离的同时，做到了实现自身又包含多种相互独立差异性的问题。<br/>
Runtime Registration<br/>
与真正自实现的Event Style相比,ObserverPattern的不同在哪里?</p>

<ul>
<li><p>Event Style 中需要管理多种 Event 事件；而 ObserverPattern 只通常只需要管理一种，即自己的变化</p></li>
<li><p>Event Style 中 EventRoute 有储存关于 Event 和 ObserverList 的一个 Dictionary；Observer 中 Subject 只有一个列表</p></li>
<li><p>Event Style 中 EventRoute 只是一个事件路由，没有除了一个 Dictionary 没有其他的属于自己的信息；而 Observer 中的 Subject 包含有 Subject 信息</p></li>
<li><p>Event Style 中的事件发起的原因是第三方触发了事件；而 Observer 中 update 触发的原因是 Subject 自己的数据发生了变化，虽然是由于第三方的修改，但是时间是由自己触发的</p></li>
</ul>


<p>如果众多Observer的接口不相同怎么办? 不都是update接口,甚至不是同一种类型</p>

<p>使用一个adapter使它们的接口统一</p>

<p>用 observer 编写程序</p>

<p>要求：</p>

<ul>
<li><p>Model: student（ID, name, birthday)</p></li>
<li><p>View:</p>

<ul>
<li>View1:显示ID+name</li>
<li>View2:显示ID+birthday</li>
<li>View3:修改student的三个列</li>
</ul>
</li>
<li><p>View1~2为observer,model为subject</p>

<ul>
<li>实现每次view3中实现修改后</li>
<li>View1~2自动更新<br/>
示例：<br/>
by Kavin Yao : https://gist.github.com/2977200</li>
</ul>
</li>
</ul>


<p>Creation<br/>
以singleton为基础,编写程序解决上述问题(Limited instance permited)</p>

<pre><code>import java.util.*;
public class Limiton {
  private static int limit = 3;
  private static Limiton[] instances = new Limiton[3]; 
  private static Random r = new Random();
  static {
    for (int i = 0; i &lt; limit; i++) {
      instances[i] = new Limiton();
    }
  }
  private Limiton(){}
  public static Limiton getInstance() {
    int i = r.nextInt(limit);
    return instances[i];
  }
}
</code></pre>

<p>A thread safe version:</p>

<pre><code>import java.util.*;
public class Limiton {
  private static int limit = 3;
  private static class LimitonHolder {
    private static Limiton[] instances = new Limiton[3]; 
    static {
      for (int i = 0; i &lt; limit; i++) {
        instances[i] = new Limiton();
      }
    }
  }
  private static Random r = new Random();
  private Limiton(){}
  public static Limiton getInstance() {
    int i = r.nextInt(limit);
    return LimitonHolder.instances[i];
  }
}
</code></pre>

<p>这是最简单的情况，如果需要考虑到如何选择 instance ，或者一个 instance 只能有一个外部引用，那么就要考虑其他东西了。<br/>
An Example: https://gist.github.com/2978425</p>

<p>如果有多个其他类实例的创建类型都需要子类来决定怎么办?</p>

<p>在工厂方法里的里面使用多个 factoryMethod，比如 facotryMethodA，factoryMethodB</p>

<p>如果多个其他类实例之间存在类型依赖该怎么办?</p>

<p>如果类的种类（抽象类）的个数是确定的、不会轻易改变(也就是 Product 的种类是相对稳定的)，并且类的依赖呈现 product family，那使用 Abstract Factory</p>

<p>That's All *<sup>o<sup>*</sup></sup> ~~~</p>
]]></content>
  </entry>
  
</feed>
